{"name":"Access-control-on-nfn","tagline":"Protecting the access to static data as well as data-on-demand","body":"# Access control for NDN with Named Function Networking (NFN)\r\n\r\n![Gatekeeper icon](gatekeeper.png) This projects adds an access\r\ncontrol system to NDN. It relies on an existing \"gatekeeper\"\r\nimplementation that sits between the client and the requested\r\ntarget. \"Target\" in this case can be either pre-published data or a\r\ndata-on-demand service (= named function). The gatekeeper generates\r\nand handouts a decryption key to authorized clients.\r\n\r\nWith this project we explore\r\n- how easy it is to publish a function accessible to NDN clients\r\n- how easy (for the client) it is to submit to the producer-imposed access control, also via NDN\r\n- how easy it is to write custom access controllers inside the gatekeeper\r\n\r\nSee the slide deck used to advertize this project ([Powerpoint](doc/access-ctrl-w-NFN.pptx)).\r\n\r\n\r\n## First phase (Saturday): Access control for echo() service\r\n\r\nGoal: To let an app written for NDN-js (client) request a decryption\r\nkey for a specific named service, in this case a simple echo, and then\r\ninvoke that service. Access control will be based on the identity of\r\nthe client.\r\n\r\nAchievement of Saturday: Everybody is on the same page, agreement on\r\nimplementation plan and division of labor. Summary of the design:\r\n\r\nWe align with Marxer's schema and the three \"channels\" needed for\r\naccess control: a) permission granting channel, b) key provisioning channel,\r\nc) content channel. However, we simplify the \"security dance\" and combine\r\na+b) permission and key channel.\r\n\r\nIn a first phase, the permission granting and key generating entity\r\n(gatekeeper) is co-located with the content producing entity. This\r\npermits to share the generated content encryption keys via the local\r\nfile system.\r\n\r\nSystem Architecture:\r\n\r\n![System architecture](sys-arch.png)\r\n\r\nMangled name format for requesting permission and retrieving the decryption key:\r\n\r\n~~~\r\nI: /service-provider-prefix/echo/p/<keyname>/NFN\r\nD: /service-provider-prefix/echo/p/<keyname>/NFN\r\n   payload = base64(asymencr(pubkey_keyname, encryptionKey))\r\n~~~\r\n\r\nMangled name format for requesting service invocation:\r\n\r\n~~~\r\nI: /service-provider-prefix/echo/c/<keyname, msg>/NFN\r\nD: /service-provider-prefix/echo/c/<keyname, msg>/NFN\r\n   payload = symencr(encryptionKey, msg))\r\n~~~\r\n\r\nDiscussion:\r\n\r\nShouldn't the \"p\" and \"c\" component come before the service name? Like in\r\n\r\n~~~\r\nI: /service-provider-prefix/c/echo/<params>/NFN\r\n  or\r\nI: /service-provider-prefix/c/lambda/<expr>/NFN\r\n  or\r\nI: /service-provider-prefix/c/datalog/<expr>/NFN\r\n  etc\r\n~~~\r\n\r\n\r\n## Second phase (to be discussed Sunday)\r\n\r\nCandidate targets:\r\n\r\n-  implement a content-dependend access rule e.g., threshold (which cannot be expressed at the name level)\r\n-  store data-decryption keys in the NDN memory fabric. This has the benefit that content access is possible even if the gatekeeper crashes and cannot remember the assigned data decryption keys.\r\n\r\n\r\n## Demos\r\n\r\nCandidate targets:\r\n\r\n- demonstrate access-controlled execution of lambda expression reduction\r\n- demonstrate chaining of access-controlled data filtering\r\n- demonstrate mapping of access control to database query rights\r\n\r\n\r\n## Lessons learned\r\n\r\n- use the Gatekeeper protocol to secure access to NFN\r\n\r\n----\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}